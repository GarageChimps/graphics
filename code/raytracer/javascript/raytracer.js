/**
 * Raytracer functions
 */

//Main raytracing function, recieves a scene and image size, and returns a rendered image
function rayTrace(scene, resources, width, height)
{
	setCameraBounds(scene.camera, width, height);
	var image = createImage(scene, width, height);
	for(var i=0; i<width; i++)
	{
		for(var j=0; j<height; j++)
		{
			var ray = generatePixelRay(scene.camera, i, j, width, height);
			image[i][j] = intersectAndShade(ray, scene, resources, 0);
		}
	}
	return image;
}

//Initialize a matrix to store the image to be rendered
function createImage(scene, width, height)
{
	var image = new Array(width);
	for(var i=0; i<width; i++)
	{
		image[i] = new Array(height);
		for(var j=0; j<height; j++)
		{
			image[i][j] = scene.getBackgroundColor();
		}
	}
	return image;
}

//Generates a pixel view ray from the pixel coordinates
function generatePixelRay(camera, i, j, width, height)
{
	var cameraCoords = pixelToCameraCoords(camera, i, j, width, height);
	var worldCoords = cameraToWorldCoords(camera, cameraCoords);
	var pixelDirection = normalize(sub(worldCoords, camera.position));
	return {
		position : camera.position,
		direction : pixelDirection
	}
}

//For a given ray, tests objects intersection and calculate corresponding color
function intersectAndShade(ray, scene, resources, recursion)
{
	if(recursion > scene.getParam("maxReflectionRecursions"))
		return scene.getBackgroundColor();
	var intersectResult = intersectAllObjects(ray, scene);
	var tIntersect = intersectResult[0];
	var indexIntersect = intersectResult[1];
	if(tIntersect < Infinity)
		return getRayColor(ray, tIntersect, scene.objects[indexIntersect], scene, resources, recursion);
	return scene.getBackgroundColor();
}

//Check intersection between ray and all objects of the scene
function intersectAllObjects(ray, scene)
{
	var tMin = Infinity;
	var indexMin = -1;
	for(var index = 0; index < scene.objects.length; index++)
	{
		var t = scene.objects[index].intersect(ray);
		if (t < tMin)
		{
			tMin = t;
			indexMin = index;
		}
	}
	return [tMin, indexMin];
}

//Calculates the color gathered by this ray after intersecting an object
function getRayColor(ray, tIntersection, object, scene, resources, recursion)
{
	var p = add(ray.position, mult_scalar(tIntersection, ray.direction));
	var n = normalize(sub(p, object.position));
	return shade(p, n, ray.direction, object.materials, scene, resources, recursion);
}

//Performs the shading calculation for a point, based on material reflectances and lights illumination
function shade(p, n, d, materials, scene, resources, recursion)
{
	var color = [0,0,0];
	color = add(color, getAmbientColor(materials, scene, resources));
	color = add(color, getShadingColor(p, n, d, materials, scene, resources, recursion));
	return color;
	
}

//Returns the ambient color generated by the ambient illumination of the scene for a material
function getAmbientColor(materials, scene, resources)
{
	var color = [0,0,0];
	var ambientMaterials = resources.getAmbientMaterials(materials)
	var ambientLights = scene.getAmbientLights();
	for(var i=0; i<ambientLights.length; i++)
	{
		for(var j=0; j<ambientMaterials.length; j++)
		{
			var material = ambientMaterials[j];
			var ambientColor = mult(ambientLights[i].color, material.color);
			color = add(color, ambientColor);
		}
	}
	return color;
}

//Returns the shading color generated by the shading illumination of the scene for a material
function getShadingColor(p, n, d, materials, scene, resources, recursion)
{
	var color = [0,0,0];
	var v = normalize(sub(scene.camera.position, p));
	var brdfMaterials = resources.getBrdfMaterials(materials)
    var reflectiveMaterials = resources.getReflectiveMaterials(materials)
	var shadingLights = scene.getShadingLights();

	for(var i=0; i<shadingLights.length; i++)
	{		
		var lightPos = shadingLights[i].position;
		var l = shadingLights[i].getDirection(p);
		if(!isInShadow(p, l, scene))
		{
			var lightColor = shadingLights[i].color;
			for(var j=0; j<brdfMaterials.length; j++)
			{
				var material = brdfMaterials[j];
				var brdfVal = material.brdf(n,l,v, material.brdfParams);
				var materialColor = mult(lightColor, mult_scalar(brdfVal, material.color));
				color = add(color, materialColor);
			}
		}
		for(var j=0; j<reflectiveMaterials.length; j++)
		{
			var material = reflectiveMaterials[j];
			var reflectionRay = getReflectionRay(p, n, d);
			var rayColor = intersectAndShade(reflectionRay, scene, resources, recursion + 1);
			var materialColor = mult_scalar(material.reflectivity, rayColor);
			color = add(color, materialColor);
		}

	}
	return color;
}

//Generates a shadow ray for a given point p for light l
function generateShadowRay(p, l)
{
	var q = add(p, mult_scalar(0.001, l));
	return {
		position : q,
		direction : l
	}
}

//Tests if a point p is in shadow for a given light l in the given scene
function isInShadow(p, l, scene)
{
	var ray = generateShadowRay(p, l);
	var intersectResult = intersectAllObjects(ray, scene);
	var tIntersect = intersectResult[0];
	return tIntersect < Infinity;
}

//Gets the reflection ray in a point p with normal n based on original viewing direction d
function getReflectionRay(p, n, d)
{
	var r = normalize(sub(d, mult_scalar(dot(d,n)*2, n)));
	var q = add(p, mult_scalar(0.001, r));
	return {
		position : q,
		direction : r
	}
}
















