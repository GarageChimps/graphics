/**
 * Raytracer functions
 */

//Main raytracing function, recieves a scene and image size, and returns a rendered image
function rayTrace(scene, width, height)
{
	var image = createImage(scene, width, height);
	for(var i=0; i<width; i++)
	{
		for(var j=0; j<height; j++)
		{
			var ray = generatePixelRay(scene.camera, i, j, width, height);
			image[i][j] = intersectAndShade(ray, scene, 0);
		}
	}
	return image;
}

//Initialize a matrix to store the image to be rendered
function createImage(scene, width, height)
{
	var image = new Array(width);
	for(var i=0; i<width; i++)
	{
		image[i] = new Array(height);
		for(var j=0; j<height; j++)
		{
			image[i][j] = scene.background;
		}
	}
	return image;
}

//Generates a pixel view ray from the pixel coordinates
function generatePixelRay(camera, i, j, width, height)
{
	var cameraCoords = pixelToCameraCoords(camera, i, j, width, height);
	var worldCoords = cameraToWorldCoords(cameraCoords, camera);
	var pixelDirection = normalize(sub(worldCoords, camera.position));
	return {
		position : camera.position,
		direction : pixelDirection
	}
}

//For a given ray, tests objects intersection and calculate corresponding color
function intersectAndShade(ray, scene, recursion)
{
	if(recursion > scene.maxReflectionRecursions)
		return scene.background;
	var intersectResult = intersectAllObjects(ray, scene);
	var tIntersect = intersectResult[0];
	var indexIntersect = intersectResult[1];
	if(tIntersect < Infinity)
	 return getRayColor(ray, tIntersect, scene.spheres[indexIntersect], scene, recursion);
	return scene.background;
}

//Check intersection between ray and all objects of the scene
function intersectAllObjects(ray, scene)
{
	var tMin = Infinity;
	var indexMin = -1;
	for(var index = 0; index < scene.spheres.length; index++)
	{
		var t = intersectSphere(ray, scene.spheres[index]);
		if (t < tMin)
		{
			tMin = t;
			indexMin = index;
		}
	}
	return [tMin, indexMin];
}

//Checks intersection between ray and specific sphere
function intersectSphere(ray, sphere)
{
	  var a = dot(ray.direction, ray.direction);
	  var b = 2* dot(sub(ray.position, sphere.position), ray.direction);
	  var c = dot(sub(ray.position, sphere.position), sub(ray.position, sphere.position)) - sphere.radius*sphere.radius;

	  var discr = b*b - 4*a*c;
	  if(discr < 0.0)
			return Infinity;

	  discr = Math.sqrt(discr);
	  var t0 = (-b - discr) / (2*a);
	  var t1 = (-b + discr) / (2*a);

	  var tMin = Math.min(t0, t1);
	  if(tMin < 0.0)
			return Infinity;

	  return tMin;
}

//Calculates the color gathered by this ray after intersecting an object
function getRayColor(ray, tIntersection, object, scene, recursion)
{
	var p = add(ray.position, mult_scalar(tIntersection, ray.direction));
	var n = normalize(sub(p, object.position));
	return shade(p, n, ray.direction, object.materials, scene, recursion);
}

//Performs the shading calculation for a point, based on material reflectances and lights illumination
function shade(p, n, d, materials, scene, recursion)
{
	var color = getAmbientColor(resources.materials[materials[0]], scene)
	var v = normalize(sub(scene.camera.position, p));

	for(var i=0; i<scene.pointLights.length; i++)
	{
		var lightColor = scene.pointLights[i].color;
		var lightPos = scene.pointLights[i].position;
		var l = normalize(sub(lightPos, p));
		if(isInShadow(p, l, scene))
			lightColor = [0,0,0];

		for(var j=0; j<materials.length; j++)
		{
			var material = resources.materials[materials[j]];
			if(material.type == "brdf")
			{
				var brdfVal = material.brdf(n,l,v, material.brdfParams);
				var materialColor = mult(lightColor, mult_scalar(brdfVal, material.color));
			}
			else if(material.type == "mirror")
			{
				var reflectionRay = getReflectionRay(p, n, d);
				var materialColor = intersectAndShade(reflectionRay, scene, recursion + 1);
			}
			color = add(color, materialColor);
		}

	}
	return color;
}

//Returns the ambient color generated by the ambient illumination of the scene for a material
function getAmbientColor(material, scene)
{
	var color = [0,0,0];
	for(var i=0; i<scene.ambientLights.length; i++)
	{
		var ambientColor = mult(scene.ambientLights[i].color, material.color);
		color = add(color, ambientColor);
	}
	return color;
}

//Generates a shadow ray for a given point p for light l
function generateShadowRay(p, l)
{
	var q = add(p, mult_scalar(0.001, l));
	return {
		position : q,
		direction : l
	}
}

//Tests if a point p is in shadow for a given light l in the given scene
function isInShadow(p, l, scene)
{
	var ray = generateShadowRay(p, l);
	var intersectResult = intersectAllObjects(ray, scene);
	var tIntersect = intersectResult[0];
	return tIntersect < Infinity;
}

//Gets the reflection ray in a point p with normal n based on original viewing direction d
function getReflectionRay(p, n, d)
{
	var r = normalize(sub(d, mult_scalar(dot(d,n)*2, n)));
	var q = add(p, mult_scalar(0.001, r));
	return {
		position : q,
		direction : r
	}
}
















